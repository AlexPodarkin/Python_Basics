import sys

print('Зарезервированное слово del не удаляет объекты в Python. Оно разрывает связь между переменной и объектом,'
      ' на который переменная указывает. После строки с del к переменной нельзя обратиться, а у объекта на '
      'единицу уменьшается счётчик ссылок.')


class User:
    """Как и при создании функции, при создании классов принято оставлять
    документацию к нему. Для этого достаточно использовать многострочный
    комментарий сразу после определения класса"""
    def __init__(self, name, equipment=None):
        self.equipment = [] if equipment is None else equipment
        self.name = name
        print(f'создание экземпляра {self.name}')

    def __del__(self):
        print(f'удаление экземпляра {self.name}')

    def __str__(self):
        eq = ','.join(self.equipment) if self.equipment else 'пусто'
        return f'перед нами : {self.name}, с оборудованием: {eq}'

    def __repr__(self):
        return f'User("{self.name}")'


user_1 = User('Alex')
print(f'Количество ссылок на объект {sys.getrefcount(user_1) - 1}')
user_2 = user_1
print(f'Количество ссылок на объект {sys.getrefcount(user_1) - 1}')
del user_2
print(f'Количество ссылок на объект {sys.getrefcount(user_1) - 1}')
del user_1
# удаление экземпляра Alex произошло раньше завершения работы приложения
print('Завершение работы')

print('Метод __str__ обязан вернуть строку str. Обычно это строка содержит информацию '
      'о свойствах класса для понимания что за экземпляр перед нами. '
      'Упор делается на удобство чтения. Но и о краткости забывать не стоит')
user_1 = User('Alex', ['дрель', 'палка'])

print('Метод __str__ -> ', user_1)
# print(user_1.__str__())

print('Представление для создания экземпляра, __repr__, Дандер метод __repr__ аналогичен __str__,'
      ' но возвращает максимально близкое к созданию экземпляра класса представление.')
print(user_1.__repr__())

print('При вызове функции print сработал метод __str__. Как же получить вывод от__repr__ '
      'при наличии двух методов? Есть несколько способов вывода на печать:')
# __str__
print(user_1)
print(f'{user_1}')
# __repr__
print(repr(user_1))
print(f'{user_1 = }')
print('Однако метод __repr__ оказывается более приоритетным,'
      ' если на печать выводится не один элемент, а коллекция элементов.')
user_2 = User('Alex2')
print([user_1, user_2])
print('И только при распаковке списка через звёздочку функция print '
      'получает экземпляры напрямую и вызывает их дандер __str__.')
print(*[user_1, user_2], sep=' || ')
